\subsection{Motivation und Relevanz}
\label{sec:1_Relevanz}

Zu Beginn muss geklärt werden, was eine Softwarekomponente im Allgemeinen definiert. 1996 wurde die Softwarekomponente bei der European Conference on Object-Oriented Programming (ECOOP) folgendermaßen definiert \autocite{Szyperski.2002}:
\begin{quote}
\glqq A software component is a unit of composition with contractually specified interfaces and explicit context dependencies only. A software component can be deployed independently and is subject to composition by third parties.\grqq
\end{quote}
Um dies näher zu erläutern, wird ein gängiger Tätigkeitsbereich eines Softwarearchitekten herangezogen: das Erstellen einer Liste von Komponenten, die in die gesamte Architektur problemlos eingefügt werden kann. Diese Liste gibt dem Entwicklungsteam vor, welche Komponenten das Softwaresystem zum Schluss umfassen wird. In einfachen Worten zusammengefasst sind Softwarekomponenten die Teile, die eine Software zum Ganzen machen \citereset \autocite{Szyperski.2002}.

Komponentenentwicklung steht für die Herstellung von Komponenten, die eine spezielle Funktion in einer Softwarearchitektur übernehmen. Sämtliche Komponenten sollten immer für sich gekapselt und unabhängig von einander sein. Mehrere Komponenten werden mit Hilfe eines Verbindungsverfahren zusammengeführt beziehungsweise verwendet.

Softwarekomponente haben ihren Ursprung im \glqq Unterprogramm\grqq . Ein \glqq Unterprogramm\grqq , oder auch \glqq Subroutine\grqq\ genannt, ist ein Teil einer Software, die von anderen Programmen beziehungsweise Programmteilen aufgerufen werden kann. Eine Subroutine gilt als Ursprung der ersten Einheit für die Softwarewiederverwendung \autocite{Wheeler.1985}. Programmierer entdeckten, dass sie sich auf die Funktionalität von zuvor geschriebenen Codesegmenten berufen können, ohne sich beispielsweise um ihre Implementierung kümmern zu müssen. Neben der Zeitersparnis, die dadurch entstand, erweiterte diese \glqq Technik \grqq\ unser Denken:
der Fokus kann auf neue Algorithmen und komplexere Themen gelegt werden. Des Weiteren entwickelten sich auch die Programmiersprachen weiter. Anspruchsvolle Subroutines waren ununterscheidbar von primitiven, atomaren Anweisungen \autocite{Szyperski.2002}.

Komponentenbasierte Softwareentwicklung entwickelte sich in einer ununterbrochenen Linie von diesen frühen Anfängen. Moderne Komponenten, von denen die meisten webbasierte Services sind, sind viel größer und viel anspruchsvoller, als früher. Des Weiteren haben die neuen Komponenten eine dienstorientierte Architektur, was zu höherer Komplexität betreffend der Interaktionsmechanismen führt, als die damaligen Subroutinen \autocite{Andresen.2003}.

In der gleichen Weise, wie die frühen Subroutinen die Programmierer vom Nachdenken über spezifische Details befreit haben, verschiebt sich durch komponentenbasierte Softwareentwicklung der Schwerpunkt von direkter Programmiersoftware zu komponierten Softwaresystemen, sprich komponentenbasierten Systemen. Auf der Grundlage, dass der Schwerpunkt auf der Integration von Komponenten liegt, basiert die Annahme, dass es genügend Gemeinsamkeiten in  großen Softwaresystemen gibt, um die Entwicklung von wiederverwendbaren Komponenten zu rechtfertigen und um dafür diese Gemeinsamkeiten ausnutzen zu können. Heute werden Komponente gesucht, die eine große Sammlung von Funktionen bereitstellen. Beispielsweise wird aus unternehmerischer Sicht nicht nach einem simplen Adressbuch, um die Daten beziehungsweise Kommunikation seiner Kunden zu sichern, sondern eine CRM-System\footnote{Ein \glqq Customer Relationship Management System\grqq\ bezeichnet ein System, das zur Kundenpflege beziehungsweise Kundenkommunikation dient.} gesucht. Darüberhinaus sollte dieses System auch flexibel sein, d.h. es sollte mit anderen Komponenten erweiterbar sein. Die Auswirkungen, wenn die Kontrolle über die Zerlegung in die jeweiligen Komponenten vorhanden ist beziehungsweise wenn diese Kontrolle nicht vorhanden ist, werden in der Bachelorarbeit näher besprochen\citereset \autocite{Andresen.2003}.

Komponentenbasierte Entwicklung dient der Verwaltung von Komplexität in einem System. Sie versucht diese Verwaltung zu erreichen, indem die Programmiererin und der Programmierer sich vollständig auf die Implementierung der Komponente fokussieren. Das Verknüpfen beziehungsweise Kombinieren von Komponenten sollte nicht mehr Aufgabe des Komponentenentwickler sein. Um diese Aufgabe zu lösen wird ein spezielles Framework oder externe Struktur der Komponente verwendet. Vorteile durch dieses Programmierparadigma sind somit einerseits die Zeitersparnisse und andererseits die erhöhte Qualität der Komponenten. Dadurch, dass bei der komponentenbasierten Entwicklung die Wiederverwendbarkeit von Komponenten im Vordergrund steht, gibt es verschiedene Anwendungsszenarien, die automatisch als Testszenarien dienen\citereset \autocite{Andresen.2003}.

Im Zeitalter von Internet, Intranet und Extranet sind viele verschiedene Systeme und Komponenten miteinander zu verzahnen. Web-basierte Lösungen sollen auf Informationen eines Hostrechners zugreifen können, um z.B. mittels eines Unternehmensübergreifenden Extranets diversen Zwischenhändlern transparente Einblicke in die Lagerbestände eines Unternehmens zu ermöglichen. ERP\footnote{Enterprise Resource Planning}- und CRM-Systeme sollen eingebunden werden, um die Betreuung und den Service für Kunden zu optimieren. Aus diesen Gründen ist eine erweiterbare und flexible Architektur notwendig, die eine schnelle Reaktion auf neue Anforderungen ermöglicht.

Um diesen Anforderungen gerecht zu werden, gab es in den letzten Jahren eine unüberschaubare Anzahl an Frameworks beziehungsweise Bibliotheken, die die Entwickler unterstützten. Eine neue Technologie, die derzeit vom W3C versucht wird zu standardisieren, gehört zu den interessantesten neuen Webtechniken. Diese Technologie versucht eine Vielzahl von Funktionen der populärsten JavaScript-Komponentenframeworks aufzunehmen und nativ in den Browser zu portieren. Dadurch wird es möglich sein eigene Komponenten und Applikationen entwickeln zu können, welche die Vorteile dieser Technologie, die zuvor nur begrenzt durch Einbindung zahlreicher Bibliotheken beziehungsweise unter Verwendung zahlreicher Frameworks, nutzen.

Unter \glqq Web-Components\grqq\ versteht man ein Komponentenmodell, das 2013 in einem Arbeitsentwurf des W3C veröffentlicht wurde. Es besteht aus fünf Teilen:
\begin{description}
\item[Templates] beinhalten Markup, das vorerst inaktiv ist, aber bei späterer Verwendung aktiviert werden kann.
\item[Decorators] verwenden CSS-Selektoren basierend auf den Templates, um visuelle beziehungsweise verhaltensbezogene Änderungen am Dokument vorzunehmen.
\item[Custom Elements] ermöglichen eigene Elemente mit neuen Tag-Namen und neuen Skript-Schnittstellen zu definieren.
\item[Shadow DOM] erlaubt es eine DOM-Unterstruktur vollständig zu kapseln, um so zuverlässigere Benutzerschnittstellen der Elemente garantieren zu können.
\item[Imports] definieren, wie Templates, Decorators und Custom Elements verpackt und als eine Ressource geladen werden können.
\end{description}
Dieses Komponentenmodell hat das Potenzial, die Entwicklung von Web-Applikationen enorm zu vereinfachen und zu beschleunigen. Mit Hilfe von \glqq Custom Elements\grqq\ und \glqq Imports \grqq\ lassen sich eigene, komplexe HTML-Elemente selbst bauen oder von anderen entwickelte Elemente in der eigenen Applikation oder Website nutzen. Beispielsweise könnte ein eigenes HTML-Element von einer einfachen Überschrift mit fest definiertem Aussehen, über einen Videoplayer, bis hin zu einer kompletten Applikation, alles sein. Vieles, was heute über Javascript-Bibliotheken abgewickelt wird, könnte künftig in Form einzelner Webkomponenten umgesetzt werden. Das verringert Abhängigkeiten und sorgt für mehr Flexibilität. Bis die dafür notwendigen Webstandards aber verabschiedet, in Browsern umgesetzt und diese bei ausreichend Nutzern installiert sind, wird aber noch einige Zeit vergehen. Google hat daher mit Polymer eine Bibliothek entwickelt, die die Nutzung von Webkomponenten schon heute ermöglicht und dazu je nach den im Browser vorhandenen Funktionen die fehlenden Teile ergänzt.

Die persönliche Motivation beziehungsweise Relevanz zu diesem Thema ist durch das praxisnahe Projekt gegeben. Hierbei wird der Fokus auf die Programmierung von zwei wiederverwertbaren Frontend-Oberflächen gelegt. Zum einen wird eine Diagramm-Komponente und zum anderen ein komplexes Menü entwickelt, dass für folgende Projekte weiterverwendet werden kann. Die Hauptanforderung ist die Kompatibilität zu so vielen Browsern wie möglich zu gewährleisten. Des Weiteren soll durch die einmalige Programmierung dieser Komponente und deren darauffolgende Wiederverwendung den Wartungsaufwand möglichst gering zu halten. Somit wird in dieser Arbeit geklärt, inwiefern die Entwicklung von Web-Components ohne Unterstützungen wie beispielsweise das Polymer Projekt bereits möglich ist. Des Weiteren soll geklärt werden, welche Aspekte der klassischen Softwarearchitektur bei der Entwicklung von Web-Components aufgegriffen werden und inwiefern es mit komponentenbasierter Softwareentwicklung beziehungsweise komponentenbasierter Softwarearchitektur vereinbar ist. Folgend werden diese Aspekte nicht nur an Hand der zur Zeit standardisierten Web-Components Technologie analysiert, sondern auch an Hand des von Google zur Verfügung gestellten Polyfills.
