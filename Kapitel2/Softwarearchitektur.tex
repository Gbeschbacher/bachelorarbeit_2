\subsection{Softwarearchitektur}
\label{sec:2_Softwarearchitektur}

Architektur ist nicht ausschließlich eine technologische Angelegenheit, sondern beinhaltet zahlreiche soziale und organisatorische Gesichtspunkte, die den Erfolg einer Architektur und damit eines gesamten Projekts erheblich beeinflussen können.

Dadurch, dass Architektur in verschiedenen Bereichen relevant ist und unterschiedliche Aspekte bei der Erstellung eines Systems umfasst, fällt eine allgemeingültige Definition schwer \citereset \autocite[siehe][S. 8-11]{Vogel.2009}.

Zu Beginn wird die klassische Architektur als Ausgangspunkt verwendet. Eine mögliche Definition der klassischen Architektur bietet das \glqq American Heritage Dictionary\footnote{Siehe \href{http://ahdictionary.com/word/search.html?q=architecture&submit.x=39&submit.y=20}{American Heritage Online-Dictionary}}\grqq :
\begin{quote}
  Architecture is:
  \begin{enumerate}
    \item The art and science of designing and erecting buildings.
    \item A style and method of design and construction
    \item Orderly arrangement of parts
  \end{enumerate}
\end{quote}

Diese Definition legt zu Grunde, dass Architektur sowohl eine Kunst als auch eine Wissenschaft ist, die sich sowohl mit dem Entwerfen, als auch mit dem Bauen von Bauwerken beschäftigt. Sie konzentriert sich nicht nur auf die Planung, sondern erstreckt sich bis hin zu der Realisierung eines Bauwerks. Ferner ist ein Schlüsselergebnis der Architekturtätigkeit das Arrangieren von Teilen des Bauwerks. Laut dieser Definition ist Architektur hiermit nicht nur die Struktur eines Bauwerks, sondern auch die Art und Weise, an etwas heranzugehen. Grundlegend basieren Architekturen auf gewissen Anforderungen und Werkzeugen, mit denen die Anforderungen umgesetzt werden. Ein Beispiel in diesem Kontext wäre der Wunsch nach einer Behausung, welcher unter Verwendung von vorhandenen Mitteln (Werkzeugen) realisiert werden kann.

Historisch basiert der eigentliche Entwurf auf dem Prinzip von Versuch und Irrtum. Erst durch die gewonnenen Architektur-Erfahrungen, welche mündlich oder schriftlich weitergegeben wurden, entwickelten sich Architekturstile. Folglich basiert Architektur auf Konzepten beziehungsweise Methoden, die sich in der Vergangenheit bewährt haben \citereset \autocite[siehe][S. 41-68]{Vogel.2009}.

Zum Begriff \glqq Architektur\grqq\ in der IT existieren im Gegensatz zur klassischen Architektur unzählige Definitionen\footnote{Das Software Engineering Institute (SEI) der Carnegie-Mellon Universität der Vereinigten Staaten von Amerika hat in der Fachliteratur über 50 verschiedene Definitionen für den Begriff \glqq Softwararchitektur\grqq\ ausgemacht (\href{http://www.sei.cmu.edu/architecture/definitions.html}{Software Architecture Definitions}).}. Daran zeigt sich, dass es eine Herausforderung darstellt eine Definition zu finden, die allgemein anerkannt wird \citereset \autocite[siehe][]{Shaw.1996}.

Softwarearchitektur erstreckt sich von der Analyse des Problembereichs eines Systems bis hin zu seiner Realisierung. Sie bewegt sich nicht auf der Abstraktionsebene fein-granularer Strukturen wie Klassen oder Algorithmen, sondern vielmehr auf der Ebene von Systemen, also grob-granularer Strukturen. Oftmals werden bei Projekten keine Aufwände im Zusammenhang mit Architektur bezahlt, was dazu führt, dass es im späteren Verlauf der Entwicklung zu vermeidbaren höheren finanziellen Kosten auf Grund eines erhöhten Wartungsaufwands kommen kann \citereset \autocite[siehe][S. 8-11]{Vogel.2009}.

\begin{description}
\item[Symptome mangelhafter Softwarearchitektur] \hfill \\
  Fatalerweise zeigen sich die Folgen einer mangelhaften Architektur in der IT nicht selten erst mit erheblicher Verzögerung. Dies bedeutet, dass ernste Probleme eventuell erst wenn ein System zum ersten Mal produktiv eingesetzt wird auftreten. Eine Architektur, die ungeplant entstanden ist, sich also unbewusst im Laufe der Zeit entwickelt hat, führt zu erheblichen Problemen während der Erstellung, der Auslieferung und dem Betrieb eines Systems. Folgende Symptome können potentiell auf eine mangelhafte Architektur hindeuten \citereset \autocite[siehe][S. 6-8]{Vogel.2009}:
  \begin{itemize}
  \item Fehlender Gesamtüberblick
  \item Komplexität ufert aus und ist nicht mehr beherrschbar
  \item Planbarkeit ist erschwert
  \item Risikofaktoren frühzeitig erkennen ist kaum möglich
  \item Wiederverwendung von Wissen und Systembausteinen ist erschwert
  \item Wartbarkeit ist erschwert
  \item Integration verläuft nicht reibungslos
  \item Performance ist unzureichend
  \item Architektur-Dokumentation ist unzureichend
  \item Funktionalität beziehungsweise Quelltext ist redundant
  \item Systembausteine besitzen zahlreiche unnötige Abhängigkeiten untereinander
  \item Entwicklungszyklen sind sehr lang
  \end{itemize}
\item[Folgen mangelhafter Softwarearchitektur] \hfill \\
  Die Folgen einer mangelhaften Softwarearchitektur wurde dem Buch \glqq Software-Architektur: Grundlagen - Konzepte - Praxis\grqq\ von Oliver Vogel entnommen \citereset \autocite[siehe][6-8]{Vogel.2009}:
  \begin{itemize}
  \item Schnittstellen, die schwer zu verwenden beziehungsweise zu warten sind weil sie einen zu großen Umfang besitzen.
  \item Quelltext, der an zahlreichen Stellen im System angepasst werden muss, wenn Systembausteine, wie beispielsweise Datenbank oder Betriebssystem, geändert werden.
  \item Klassen, die sehr viele ganz unterschiedliche Verantwortlichkeiten abdecken und deshalb nur schwer wiederzuverwenden sind (\glqq Monster\grqq -Klassen).
  \item Fachklassen, deren Implementierungsdetails im gesamten System bekannt sind.
  \end{itemize}
\item[Vorteile von Architektur] \hfill \\
  Unabhängig davon, welche Art von System entwickelt wird, legt eine Architektur immer die Fundamente fest. Die Details, die für das zu entwickelnde System notwendig sind, werden nicht von einer Architektur festgelegt \citereset \autocite[siehe][]{Buschmann.1996} nach \citereset \autocite[siehe][S. 6-8]{Vogel.2009}. Folglich wird Architektur von den Fundamenten definiert, ohne auf deren interne Details einzugehen. Folgende Fragen im Hinblick auf ein System werden durch eine Architektur beantwortet:
  \begin{itemize}
  \item Auf welche Anforderungen sind Strukturierung und Entscheidungen zurückzuführen?
  \item Welches sind die wesentlichen logischen und physikalischen Systembausteine?
  \item Wie stehen die Systembausteine in Beziehung zueinander?
  \item Welche Verantwortlichkeiten haben die Systembausteine?
  \item Wie sind die Systembausteine gruppiert beziehungsweise geschichtet?
  \item Was sind die Kriterien, nach denen das System in Bausteine aufgeteilt wird?
  \end{itemize}
Architektur beinhaltet demnach alle fundamentalen Festlegungen und Vereinbarungen, die zwar durch die fachliche Anforderungen angestoßen worden sind, sie aber nicht direkt umsetzt.
\end{description}

Ein wichtiges Charakteristikum von Architektur ist die Handbarkeit und Überschaubarkeit von Komplexität. Sie zeigt nur die wesentlichen Aspekte eines Systems, ohne zu sehr in die Details zu gehen. So ermöglicht Architektur in relativ kurzer Zeit einen Überblick über ein System zu erlangen.

Die Festlegung, was genau die Fundamente und was die Details eines Systems sind, ist subjektiv beziehungsweise kontextabhängig. Gemeint sind in jedem Fall die Dinge, welche sich später nicht ohne Weiteres ändern lassen. Dabei handelt es sich um Strukturen und Entscheidungen, welche für die Entwicklung eines Systems im weiteren Verlauf eine maßgebliche Rolle spielen \citereset \autocite[siehe][]{Fowler.2005}. Beispiele hierfür sind die Festlegung, wie Systembausteine ihre Daten untereinander austauschen oder die Auswahl der Komponentenplattform\footnote{Beispiele für Komponentenplattformen sind \href{http://www.oracle.com/technetwork/java/javaee}{JEE}, \href{http://www.microsoft.com/net}{.NET}, \href{http://www.adobe.com/at/products/air.html}{Adobe AIR} und viele mehr\ldots }. Derartige architekturrelevante Festlegungen wirken sich systemweit aus im Unterschied zu architekturirrelevanten Festlegungen (wie beispielsweise eine bestimmte Implementierung einer Funktion), die nur lokale Auswirkungen auf ein System haben \citereset \autocite[siehe][]{Bredemeyer.Malan.2004}.

\subsubsection{Serviceorientierte Softwarearchitektur}
\label{sec:2_Serviceorientierte_Softwarearchitektur}
Mit Hilfe von SOAs (serviceorientierte Softwarearchitektur) können verteilte Systeme entwickelt werden. Hierbei können die Systemkomponenten eigenständige Dienste darstellen. Das System selbst kann auf geographisch verteilten Rechnern laufen. Die standardisierten XML-basierten Protokolle wurden dafür entwickelt, um die Dienstkommunikation und den Informationsaustausch unter diesen Diensten zu unterstützen. Folglich sind Dienste sowohl Plattform- als auch sprachunabhängig implementiert. Software-Systeme können durch Kompositionen lokaler und externer Dienste, welche nahtlos miteinander interagieren, aufgebaut werden \citereset \autocite[siehe][S. 509-514]{Sommerville.2011}.

\begin{figure}[h]
\centering
\includegraphics[height=5.0cm]{images/soa.png}
\caption[
Serviceorientierte Architektur, Urldate: 04.2014 \newline
\small\texttt{\url{http://www.w3.org/2003/Talks/0521-hh-wsa/slide5-0.html}}
]{Serviceorientierte Architektur}
\label{fig:2_SOA}
\end{figure}

Eine Vielzahl von Unternehmen, darunter auch Microsoft, haben solche Dienstverwaltungen anfangs des 21. Jahrhunderts eingerichtet. Sie waren lediglich für die Suche von externen Services errichtet worden. Durch die rasche Entwicklung der Suchmaschinentechnologie vereinfachten diese die Benutzung von Suchmaschinen stark. Sie galten rasch als die bevorzugte Variante um externe Services zu suchen und somit haben sich Dienstverwaltungen als redundant herausgestellt \citereset \autocite[siehe][S. 511]{Sommerville.2011}.

Applikationen basierend auf Diensten zu entwickeln erlaubt es Unternehmen und anderen Organisationen zu kooperieren, indem sie die Dienste des jeweils anderen benutzen. Dies bedeutet, dass die Geschäftslogik, die mit Hilfe eines Dienstes erreichbar ist, auch anderen Unternehmen über diesen Dienst zur Verfügung steht. Systeme, die einen umfangreichen Informationsaustausch über deren geographische Grenzen haben, können mit Hilfe von Services automatisiert werden. Ein Beispiel in diesem Kontext wäre ein Lieferketten-System, das in gewissen Zeitabständen Artikel über ein anderes System kauft.
Die Bestellung des Artikels wird über den speziellen Dienst des anderen Unternehmens abgewickelt \citereset \autocite[siehe][S. 512]{Sommerville.2011}.

Grundsätzlich sind SOAs lose gekoppelt, wobei die Dienstbindungen sich während der Laufzeit noch ändern können. Dies bedeutet, dass eine andere, jedoch äquivalente Version des Dienstes zu unterschiedlichen Zeiten ausgeführt werden kann. Einige Systeme werden ausschließlich mit Web-Diensten gebaut, andere jedoch mischen Web-Dienste mit lokal entwickelten Komponenten \citereset \autocite[siehe][S. 512]{Sommerville.2011}.

\subsubsection{Komponentenbasierte Softwarearchitektur und komponentenbasierte Softwareentwicklung}
\label{sec:2_Komponentenbasierte_Softwarearchitektur}
Eine Komponente ist ein Softwareobjekt, welches gekapselt ist und mit anderen Komponenten durch eine klar definierte Schnittstelle interagieren kann (siehe Kapitel \ref{sec:2_Softwarekomponente_Klassisch} auf Seite \pageref{sec:2_Softwarekomponente_Klassisch}). Das Ziel der komponentenbasierten Softwareentwicklung ist die Steigerung der Produktivität, Qualität und \glqq time-to market\footnote{Unter \glqq time-to market\grqq\ wird die Dauer von der Produktentwicklung bis zur Platzierung des Produkts am Markt verstanden}\grqq . Diese Steigerung soll mit dem Einsatz durch Standardkomponenten und Produktionsautomatisierungen erfolgen. Ein wichtiger Paradigmenwechsel bei dieser Entwicklungsmethode ist, dass Systeme auf Basis von Standardkomponenten aufbauen sollen, anstatt bereits funktionierende Komponenten neu zu entwickeln. Folglich ist die komponentenbasierte Softwareentwicklung eng mit dem Begriff der komponentenbasierten Softwarearchitektur verbunden. Die Architektur dieser Entwicklungsmethode bewegt sich nicht auf der Abstraktionsebene fein-granularer Strukturen wie Klassen oder Algorithmen, sondern vielmehr auf der Ebene von Systemen, also grob-granularer Strukturen \citereset \autocite[siehe][S. 452-468]{Sommerville.2011}.

Folglich muss die Definition der komponentenbasierten Softwarearchitektur hinsichtlich des bereits definierten Begriffs der Softwarearchitektur (siehe Kapitel \ref{sec:2_Softwarearchitektur} auf Seite \pageref{sec:2_Softwarearchitektur}) wie folgt erweitert werden.
Softwarearchitektur erstreckt sich von der Analyse des Problembereichs eines Systems bis hin zu seiner Realisierung. Sie ist sowohl die Identifikation, als auch die Dokumentation der einerseits statischen Struktur und andererseits der dynamischen Interaktion eines Software Systems, welches sich aus Komponenten und Systemen zusammensetzt. Dabei werden sowohl die Eigenschaften der Komponenten und Systeme als auch ihre Abhängigkeiten und Kommunikationsarten mittels spezifischer Sichten beschrieben und modelliert \citereset \autocite[siehe][S. 43]{Andresen.2003}.

Weiters erstreckt sich die komponentenbasierte Softwareentwicklung von der Definition, bis hin zur Implementierung, sowie Integrierung beziehungsweise Zusammenstellung von lose gekoppelten, unabhängigen Komponenten in Systemen. Die Grundlagen einer solchen Entwicklungstechnik sind folgende \citereset \autocite[siehe][S. 452-468]{Sommerville.2011}:
\begin{itemize}
\item Unabhängige Komponenten, die nur über klar definierte Schnittstellen erreichbar sind. Es muss eine klare Abgrenzung zwischen der Schnittstelle und der eigentlichen Implementierung der Komponente geben (siehe Abbildung \ref{sfig:Komponente_Verwender} auf Seite \pageref{sfig:Komponente_Verwender}).
\item Komponentenstandards, die die Integration von Komponenten erleichtern. Diese Standards werden an Hand eines Komponentenmodells\footnote{Beispiele für Komponentenmodelle sind \href{http://www.oracle.com/technetwork/java/javaee/ejb/index.html}{Enterprise Java Beans}, \href{https://developer.mozilla.org/de/docs/XPCOM}{Cross Platform Component Object Model}, \href{http://technet.microsoft.com/en-us/library/cc958799.aspx}{Distributed Component Object Model}, und viele mehr.} dargestellt. Mit Hilfe dieses Modells werden Standards wie beispielsweise die Kommunikation zwischen Komponenten, oder die Struktur der Schnittstelle festgelegt.
\item Middleware, die Softwareunterstützung für Komponentenintegration bereitstellt. Middleware für Komponentenunterstützung könnte beispielsweise Ressourcenallokation, Transaktionsmanagement, Sicherheit oder Parallelität sein.
\item Ein Entwicklungsprozess, der komponentenbasierte Softwareentwicklung mit komponentenbasierter Softwarearchitektur verbindet. Die Architektur benötigt einen Prozess, der es zulässt, dass sich die Anforderungen an das System entwickeln können, abhängig von der Funktionalität der zur Verfügung stehenden Komponenten.
\end{itemize}

An Hand der genannten Grundlagen der komponentenbasierten Softwareentwicklug werden die Eckpfeiler der komponentenbasierten Architektur aufgebaut \citereset \autocite[siehe][35-47]{Szyperski.2002}.
\begin{itemize}
\item Interaktionen zwischen Komponenten und deren Umfeld sind geregelt
\item Die Rollen von Komponenten sind definiert
\item Schnittstellen von Komponenten sind standardisiert
\item Aspekte der Benutzeroberflächen für Endbenutzer und Assembler sind geregelt
\end{itemize}

Diese Eckpfeiler verdeutlichen, wie eng die komponentenbasierte Softwareentwicklung in Verbindung mit komponentenbasierter Softwarearchitektur steht.

\subsubsection{Unterschied eines Dienstes und einer Komponente}
\label{sec:2_Unterschied_Dienst_Komponente}
Dienste und Komponenten haben offensichtlich viele Gemeinsamkeiten. Beide sind wiederverwendbare Elemente und es gibt nur wenige Unterschiede.

Dienste sind eine Entwicklung von Softwarekomponenten, bei denen das Komponentenmodell eine Reihe von Standards verbunden mit Webdiensten darstellt. Folglich können Dienste im Unterschied zu Komponenten wie folgt definiert werden:
Ein Webdienst ist ein Dienst, der über standardisierte XML- und Internet-Protokolle erreicht werden kann. Ein wichtiger Unterschied zwischen einem Dienst und einer Komponente ist, dass ein Dienst möglichst unabhängig und lose gekoppelt ist, während eine Komponente explizite Abhängigkeiten zu ihrem Kontext hat. Das bedeutet, dass Webdienste immer in der gleichen Weise arbeiten sollen, unabhängig von ihrer Einsatzumgebung. Die Schnittstelle eines Dienstes ist eine \glqq Offers\grqq -Schnittstelle, die den Zugriff auf die Dienstfunktionalität ermöglicht. Dienste streben einen unabhängigen Einsatz in unterschiedlichen Kontexten an. Daher haben sie nicht eine \glqq Requires\grqq -Schnittstelle, wie sie Komponenten haben. Komponenten sind meist auf zumindest eine \glqq Grundkomponente\grqq , wie beispielsweise die des Core-Systems, angewiesen.

Ein Dienst wird wie folgt benutzt:
Eine Anwendung definiert, welchen Dienst sie benötigt. Dafür werden die Anforderungen an den Dienst in einer Nachricht zu dem Dienst gesendet. Der Empfangsdienst analysiert die Nachricht, führt den angeforderten Dienst durch und sendet, nach erfolgreichem Abschluss, eine Antwort als Nachricht zurück. Die Anwendung analysiert daraufhin die Antwort auf die gewünschten Informationen.

Ein Dienst muss somit nicht lokal zur Verfügung stehen und kann als externe Datenquelle angesehen werden. Eine Komponente hingegen muss lokal verfügbar sein. Komponenten können Dienste als Schnittstelle bereitstellen, die von außen erreichbar sind. Weiters können externe Dienste für gewisse Funktionalitäten auf lokale Komponenten des externen Dienstsystems zugreifen.

Dienste können zur Auslagerung gewisser Funktionalitäten verwendet werden. Durch die Auslagerung können Applikationen um ein vielfaches kleiner gemacht werden. Ein Beispiel dafür ist die Auslagerung des \glqq Exception handling\footnote{\glqq Exception-Handling\grqq\ ist die Fehlerbehandlung zur Laufzeit, welche verhindert, dass das Programm abstürzt und nach einem Fehler noch benutzbar ist.}\grqq . Dies ist vor allem dann ein Vorteil, wenn die Applikation in Geräte eingebettet wird, bei denen es nicht möglich ist, Fehler aufzuzeichnen und nachzuvollziehen.