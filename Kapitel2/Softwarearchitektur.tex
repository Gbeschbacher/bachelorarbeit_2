\subsection{Softwarearchitektur}
\label{sec:2_Softwarearchitektur}

Architektur ist nicht ausschließlich eine technologische Angelegenheit, sondern beinhaltet zahlreiche soziale und organisatorische Gesichtspunkte, die den Erfolg einer Architektur und damit eines gesamten Projekts erheblich beeinflussen können. Wenn man bedenkt, dass Architektur in verschiedenen Bereichen ein Thema ist und unterschiedliche Aspekte bei der Erstellung eines Systems umfasst, wird deutlich, warum eine allgemeingültige Definition schwer fällt \citereset \autocite{Vogel.2009}.\\
Zu Beginn wird die klassische Architektur als Ausgangspunkt verwendet. Eine mögliche Definition der klassischen Architektur bietet das \glqq American Heritage Dictionary\footnote{Siehe \href{http://ahdictionary.com/word/search.html?q=architecture&submit.x=39&submit.y=20}{American Heritage Online-Dictionary}}\grqq :
\begin{quote}
  Architecture is:
  \begin{enumerate}
    \item The art and science of designing and erecting buildings.
    \item A style and method of design and construction
    \item Orderly arrangement of parts
  \end{enumerate}
\end{quote}

Wenn man diese Definition zugrunde legt, ist Architektur sowohl eine Kunst als auch eine Wissenschaft, die sich sowohl mit dem Entwerfen, als auch mit dem Bauen von Bauwerken beschäftigt. Sie konzentriert sich nicht nur auf die Planung, sondern erstreckt sich bis hin zu der Realisierung eines Bauwerks. Ferner ist ein Schlüsselergebnis der Architekturtätigkeit das Arrangieren von Teilen des Bauwerks. Laut dieser Definition ist Architektur hiermit nicht nur die Struktur eines Bauwerks, sondern auch die Art und Weise, an etwas heranzugehen. Generell entstehen Architekturen auf Grund von Anforderungen, wie beispielsweise der Wunsch nach einer Behausung und unter Verwendung von vorhandenen Mitteln wie zum Beispiel Werkzeugen. Historisch basiert der eigentliche Entwurf auf dem Prinzip von Versuch und Irrtum. Erst durch die gewonnenen Architektur-Erfahrungen, welche mündlich oder schriftlich weitergegeben wurden, entwickelten sich Architekturstile. Folglich basiert Architektur auf Konzepten beziehungsweise Methoden, die sich in der Vergangenheit bewährt haben \citereset \autocite{Vogel.2009}.

Zum Begriff \glqq Architektur\grqq\ in der IT existieren im Gegensatz zur klassischen Architektur unzählige Definitionen\footnote{Das Software Engineering Institute(SEI) der Carnegie-Mellon Universität der Vereinigten Staaten von Amerika hat in der Fachliteratur über 50 verschieene Definitionen für den Begriff \glqq Softwararchitektur\grqq\ ausgemacht.\href{http://www.sei.cmu.edu/architecture/definitions.html}{Software Architecture Definitions}}. Daran zeigt sich, dass es eine Herausforderung darstellt, eine Definition zu finden, die allgemein anerkannt wird \citereset \autocite{Shaw.1996}.

Softwarearchitektur erstreckt sich von der Analyse des Problembereichs eines Systems bis hin zu seiner Realisierung. Sie bewegt sich nicht auf der Abstraktionsebene fein-granularer Strukturen wie Klassen oder Algorithmen, sondern vielmehr auf der Ebene von Systemen, also grob-granularer Strukturen. Oftmals werden bei Projekten keine Aufwände im Zusammenhang mit Architektur bezahlt, was dazu führt, dass es im späteren Verlauf der Entwicklung zu vermeidbaren höheren finanziellen Kosten auf Grund eines erhöhten Wartungsaufwands kommen kann \citereset \autocite{Vogel.2009}.

\begin{description}
\item[Symptome mangelhafter Softwarearchitektur] \hfill \\
  Fatalerweise zeigen sich die Folgen einer mangelhaften Architektur in der IT nicht selten erst mit erheblicher Verzögerung, das heißt, ernste Probleme treten eventuell erst auf, wenn ein System zum ersten Mal produktiv eingesetzt wird oder wenn es bereits im Einsatz ist und für neue Anforderungen angepasst werden muss. Eine Architektur, die ungeplant entstanden ist, sich also unbewusst im Laufe der Zeit entwickelt hat, führt zu erheblichen Problemen während der Erstellung, der Auslieferung und dem Betrieb eines Systems. Folgende Symptome können potentiell auf eine mangelhafte Architektur hindeuten \citereset \autocite{Vogel.2009}:
  \begin{itemize}
  \item Fehlender Gesamtüberblick
  \item Komplexität ufert aus und ist nicht mehr beherrschbar
  \item Planbarkeit ist erschwert
  \item Risikofaktoren frühzeitig erkennen ist kaum möglich
  \item Wiederverwendung von Wissen und Systembausteinen ist erschwert
  \item Wartbarkeit ist erschwert
  \item Integration verläuft nicht reibungslos
  \item Performanz ist miserabel
  \item Architektur-Dokumentation ist unzureichend
  \item Funktionalität beziehungsweise Quelltext ist redundant
  \item Systembausteine besitzen zahlreiche unnötige Abhängigkeiten untereinander
  \item Entwicklungszyklen sind sehr lang
  \end{itemize}
\item[Folgen mangelhafter Softwarearchitektur] \hfill \\
  Diese sind folgende \citereset \autocite{Vogel.2009}:
  \begin{itemize}
  \item Schnittstellen, die schwer zu verwenden beziehungsweise zu warten sind weil sie einen zu großen Umfang besitzen.
  \item Quelltext, der an zahlreichen Stellen im System angepasst werden muss, wenn Systembausteine, wie beispielsweise Datenbank oder Betriebssystem, geändert werden.
  \item Klassen, die sehr viele ganz unterschiedliche Verantwortlichkeiten abdecken und deshalb nur schwer wiederzuverwenden sind ("Monster"-Klassen).
  \item Fachklassen, deren Implementierungsdetails im gesamten System bekannt sind.
  \end{itemize}
\item[Vorteile von Architektur] \hfill \\
  Unabhängig davon, welche Art von System entwickelt wird, legt eine Architektur ausgehend von der Anforderungen an das System immer die Fundamente und damit die tragenden Säulen, jedoch nicht die Details für das zu entwickelnde System fest (\citereset \autocite{Buschmann.1996} nach \citereset \autocite{Vogel.2009}). Architektur handelt also von den Fundamenten, ohne auf deren interne Details einzugehen. Folgende Fragen im Hinblick auf ein System werden durch eine Architektur beantwortet:
  \begin{itemize}
  \item Auf welche Anforderungen sind Strukturierung und Entscheidungen zurückzuführen?
  \item Welches sind die wesentlichen logischen und physikalischen Systembausteine?
  \item Wie stehen die Systembausteine in Beziehung zueinander?
  \item Welche Verantwortlichkeiten haben die Systembausteine?
  \item Wie sind die Systembausteine gruppiert beziehungsweise geschichtet?
  \item Was sind die Festlegungen und Kriterien, nach denen das System in Bausteine aufgeteilt wird?
  \end{itemize}
Architektur beinhaltet demnach alle fundamentalen Festlegungen und Vereinbarungen, die zwar durch die fachliche Anforderungen angestoßen worden sind, sie aber nicht direkt umsetzt.
\end{description}

Ein wichtiges Charakteristikum von Architektur ist, dass sie Komplexität überschaubar und handhabbar macht, indem sie nur die wesentlichen Aspekte eines Systems zeigt, ohne zu sehr in die Details zu gehen, und es so ermöglicht, in relativ kurzer Zeit einen Überblick über ein System zu erlangen.

Die Festlegung, was genau die Fundamente und was die Details eines Systems sind, ist subjektiv beziehungsweise kontextabhängig. Gemeint sind in jedem Fall die Dinge, welche sich später nicht ohne Weiteres ändern lassen. Dabei handelt es sich um Strukturen und Entscheidungen, welche für die Entwicklung eines Systems im weiteren Verlauf eine maßgebliche Rolle spielen \citereset \autocite{Fowler.2005}. Beispiele hierfür sind die Festlegung, wie Systembausteine ihre Daten untereinander austauschen oder die Auswahl der Komponentenplattform\footnote{Beispiele für Komponentenplattformen sind \href{http://www.oracle.com/technetwork/java/javaee}{JEE}, \href{http://www.microsoft.com/net}{.NET}, \href{http://www.adobe.com/at/products/air.html}{Adobe AIR} und viele mehr\ldots }. Derartige architekturrelevante Festlegungen wirken sich systemweit aus im Unterschied zu architekturirrelevanten Festlegungen (wie beispielsweise eine bestimmte Implementierung einer Funktion), die nur lokale Auswirkungen auf ein System haben \citereset \autocite{Bredemeyer.Malan.2004}.

\subsubsection{Serviceorientierte Softwarearchitektur}
\label{sec:2_Serviceorientierte_Softwarearchitektur}
In diesem Subkapitel wird Begriff \glqq serviceorientierte Softwarearchitektur\grqq\ mit \glqq SOA\grqq\ abgekürzt.

Mit Hilfe von SOAs können verteilte Systeme, wo die Systemkomponente eigenständige Dienste darstellen und das System selbst auf geographisch verteilten Rechnern läuft, entwickelt werden. Die standardisierten XML-basierten Protokolle wurden dafür entwickelt, um die Dienstkommunikation und den Informationsaustausch unter diesen Diensten zu unterstützen. Folglich sind Dienste sowohl Plattform- als auch sprachunabhängig implementiert. Software-Systeme können durch Kompositionen lokaler und externer Dienste, welche nahtlos miteinander interagieren, aufgebaut werden \citereset \autocite{Sommerville.2011}.

\begin{figure}[h]
\centering
\includegraphics[height=5.0cm]{images/soa.png}
\caption[
Serviceorientierte Architektur
]{Serviceorientierte Architektur}
\label{fig:2_SOA}
\end{figure}

Eine Vielzahl von Unternehmen, darunter auch Microsoft, haben solche Dienstverwaltungen anfangs des 21. Jahrhunderts eingerichtet, die sich bereits als redundant herausgestellt haben und bereits von der Suchmaschinentechnologie ersetzt wurden.

Wenn eine Applikation mit Hilfe von Diensten gebaut wird, fördert dies zugleich den Nutzen, dass andere Unternehmen auch auf diese Dienste zugreifen können. Dies kann natürlich auch in anderer Hinsicht gesehen werden, dass in seiner eigenen Applikation Dienste eines anderen Unternehmens verwendet werden können. Dies hat den Vorteil, dass Systeme, die einen hohen Datenaustausch zwischen zwei Unternehmen haben und über deren geographischen Grenzen hinausgehen, automatisiert werden können. Beispielsweise für dieses Konzept wäre eine Lieferkette zwischen zwei Unternehmen, wo ein Unternehmen Artikel über einen Dienst des anderen Unternehmens kauft.

Grundsätzlich sind SOAs lose gekoppelt, wobei die Dienstbindungen sich während der Laufzeit noch ändern können. Dies bedeutet, dass eine andere, jedoch äquivalente Version des Dienstes zu unterschiedlichen Zeiten ausgeführt werden kann. Einige Systeme werden ausschließlich mit Web-Diensten gebaut, andere jedoch mischen Web-Dienste mit lokal entwickelten Komponenten.

\subsubsection{Komponentenbasierte Softwarearchitektur und komponentenbasierte Softwareentwicklung}
\label{sec:2_Komponentenbasierte_Softwarearchitektur}
Eine Komponente ist ein Softwareobjekt, welches gekapselt ist und mit anderen Komponenten durch eine klar definierte Schnittstelle interagieren kann (siehe Kapitel \ref{sec:2_Softwarekomponente_Klassisch} auf Seite \pageref{sec:2_Softwarekomponente_Klassisch}). Das Ziel der komponentenbasierten Softwareentwicklung ist die Steigerung der Produktivität, Qualität und \glqq time-to market\footnote{Unter \glqq time-to market\grqq\ versteht man die Dauer von der Produktentwicklung bis zur Platzierung des Produkts am Markt}\grqq . Diese Steigerung soll mit dem Einsatz von einerseits Standardkomponenten und andererseits Produktionsautomatisierungen erfolgen. Ein wichtiger Paradigmenwechsel bei dieser Entwicklungsmethode ist, dass man Systeme auf Basis von Standardkomponenten bauen soll, anstatt das \glqq Rad immer wieder neu zu erfinden\grqq . Folglich ist die komponentenbasierte Softwareentwicklung eng mit dem Begriff der komponentenbasierten Softwarearchitektur verbunden. Die Architektur dieser Entwicklungsmethode bewegt sich nicht auf der Abstraktionsebene fein-granularer Strukturen wie Klassen oder Algorithmen, sondern vielmehr auf der Ebene von Systeme, also grob-granularer Strukturen \citereset \autocite{Sommerville.2011}.

Folglich muss die Definition der komponentenbasierten Softwarearchitektur hinsichtlich des bereits definierten Begriffs der Softwarearchitektur (siehe Kapitel \ref{sec:2_Softwarearchitektur} auf Seite \pageref{sec:2_Softwarearchitektur}) wie folgt erweitert werden.
Softwarearchitektur erstreckt sich von der Analyse des Problembereichs eines Systems bis hin zu seiner Realisierung. Sie ist sowohl die Identifikation, als auch die Dokumentation der einerseits statischen Struktur und andererseits der dynamischen Interaktion eines Software Systems, welches sich aus Komponenten und Systemen zusammensetzt. Dabei werden sowohl die Eigenschaften der Komponenten und Systeme als auch ihre Abhängigkeiten und Kommunikationsarten mittels spezifischer Sichten beschrieben und modelliert \citereset \autocite{Andresen.2003}.

Weiters erstreckt sich die komponentenbasierte Softwareentwicklung von der Definition, bis hin zur Implementierung, sowie Integrierung beziehungsweise Zusammenstellung von lose gekoppelten, unabhängigen Komponenten in Systemen. Die Grundlagen einer solchen Entwicklungstechnik sind folgende \citereset \autocite{Sommerville.2011}:
\begin{itemize}
\item Unabhängige Komponenten, die nur über klar definierte Schnittstellen erreichbar sind. Es muss eine klare Abgrenzung zwischen der Schnittstelle und der eigentlichen Implementierung der Komponente geben (siehe Abbildung \ref{sfig:Komponente_Verwender} auf Seite \pageref{sfig:Komponente_Verwender}).
\item Komponentenstandards, die die Integration von Komponenten erleichtern. Diese Standards werden an Hand eines Komponentenmodells\footnote{Beispiele für Komponentenmodelle sind \href{http://www.oracle.com/technetwork/java/javaee/ejb/index.html}{Enterprise Java Beans}, \href{https://developer.mozilla.org/de/docs/XPCOM}{Cross Platform Component Object Model}, \href{http://technet.microsoft.com/en-us/library/cc958799.aspx}{Distributed Component Object Model}, und viele mehr.} dargestellt. Mit Hilfe dieses Modells werden Standards wie beispielsweise die Kommunikation zwischen Komponenten, oder die Struktur der Schnittstelle festgelegt.
\item Middleware, die Softwareunterstützung für Komponentenintegration bereitstellt. Middleware für Komponentenunterstützung könnte beispielsweise Ressourcenallokation, Transaktionsmanagement, Sicherheit oder Parallelität sein.
\item Ein Entwicklungsprozess, der komponentenbasierte Softwareentwicklung mit komponentenbasierter Softwarearchitektur verbindet. Die Architektur benötigt einen Prozess, der es zulässt, dass sich die Anforderungen an das System entwickeln können, abhängig von der Funktionalität der zur Verfügung stehenden Komponenten.
\end{itemize}

An Hand der genannten Grundlagen der komponentenbasierten Softwareentwicklug werden die Eckpfeiler der komponentenbasierten Architektur aufgebaut \citereset \autocite{Szyperski.2002}.
\begin{itemize}
\item Interaktionen zwischen Komponenten und deren Umfeld sind geregelt
\item Die Rollen von Komponenten sind definiert
\item Schnittstellen von Komponenten sind standardisiert
\item Aspekte der Benutzeroberflächen für Endbenutzer und Assembler sind geregelt
\end{itemize}

Diese Eckpfeiler verdeutlichen, wie eng die komponentenbasierte Softwareentwicklung in Verbindung mit komponentenbasierter Softwarearchitektur steht.

\begin{figure}[h]
\centering
\includegraphics[height=5.0cm]{images/CBSE.png}
\caption[
Beispiel für die Interaktion zwischen zwei Komponenten, ausgedrückt in UML
]{Beispiel für die Interaktion zwischen zwei Komponenten, ausgedrückt in UML}
\label{fig:2_CBSE}
\end{figure}

\subsubsection{Unterschied eines Dienstes und einer Komponente}
\label{sec:2_Unterschied_Dienst_Komponente}
Dienste und Komponenten haben offensichtlich viele Gemeinsamkeiten. Beide sind wiederverwendbare Elemente, jedoch gibt es einige, wichtige Unterschiede zwischen Diensten und Komponenten \citereset \autocite{Sommerville.2011}.

\begin{itemize}
\item Dienste können von jedem Dienstanbieter innerhalb oder außerhalb einer Organisation offeriert werden. Wie bereits vorher erläutert, ist es möglich, eine Applikation ausschließlich auf externen Diensten basierend zu erstellen.
\item Der Dienstanbieter veröffentlicht allgemeine Informationen über den Dienst, sodass es autorisierten Benutzern möglich ist, diese zu nutzen. Es gibt keinerlei Verhandlungen zwischen dem Dienstanbieter und dem Dienstnehmer damit der Dienst benutzt werden kann.
\item Applikationen können die Bindung von Diensten bis zur Auslieferung dieser verzögern.
\item Opportunistische Entwicklungen von neuen Diensten ist möglich. Das heißt, dass ein Dienstanbieter einen neuen Dienst erkennen kann, indem bereits vorhandene Dienste auf neue, innovative Weise verknüpft werden.
\item Dienstnehmer können für Dienste gemäß ihrer Verwendung bezahlen, anstatt einer Provision. Folglich ist es möglich anstatt eine Komponente zu kaufen, die nur selten genutzt wird, einen Dienst zu benutzen, der nur dann bezahlt wird, wenn er in Verwendung ist.
\item Applikationen können um ein vielfaches kleiner gemacht werden, wenn man beispielsweise das \glqq Exception handling\grqq\ als externen Dienst implementiert. Dies ist vor allem dann ein Vorteil, wenn die Applikation in andere Geräte eingebettet wird.
\item Applikationen können reaktiv sein und sich an ihre Umgebung durch Bindung an verschiedene Dienste (je nach Umgebung) anpassen.
\end{itemize}

Dienste sind eine natürliche Entwicklung von Softwarekomponenten, bei denen das Komponentenmodell eine Reihe von Standards verbunden mit Webdiensten darstellt. Folglich können Dienste im Unterschied zu Komponenten wie folgt definiert werden:
Ein Webdienst ist ein Dienst, der über standardisierte XML- und Internet-Protokolle erreicht werden kann. Ein wichtiger Unterschied zwischen einem Dienst und einer Komponente ist, dass ein Dienst möglichst unabhängig und lose gekoppelt ist. Das bedeutet, dass sie immer in der gleichen Weise arbeiten sollen, unabhängig von ihrer Einsatzumgebung. Die Schnittstelle eines Dienstes ist eine \glqq bietet\grqq -Schnittstelle, die den Zugriff auf die Dienstfunktionalität ermöglicht. Dienste streben einen unabhängigen Einsatz in unterschiedlichen Kontexten an. Daher haben sie nicht eine \glqq erfordert\grqq -Schnittstelle, wie Komponenten sie haben. Komponenten sind meist immer auf zumindest eine \glqq Grundkomponente\grqq , wie beispielsweise die Komponente des Core-Systems, angewiesen.


Ein Dienst definiert, was er von einem anderen Dienst braucht. Dafür werden die Anforderungen des Dienstes in einer Nachricht zu dem Dienst gesendet. Der Empfangsdienst analysiert die Nachricht, führt den angeforderten Dienst durch und sendet, nach erfolgreichem Abschluss, eine Antwort als Nachricht zurück. Dieser Dienst analysiert daraufhin die Antwort auf die gewünschten Informationen. Im Gegensatz zu Komponenten benutzen Dienste keine \glqq remote procedure\grqq\ oder Methodenaufrufe um die Funktionalität des anderen Dienst erreichen zu können \citereset \autocite{Sommerville.2011}.
