\subsection{Programmierung von Web-Components mit Hilfe von Google Polymer}
\label{sec:4_WC_Polymer}

Dieses Subkapitel baut auf den bereits vorher beschriebenen Grundlagen von Google Polymer auf (siehe Kapitel \ref{sec:3_Polymer} auf Seite \pageref{sec:3_Polymer}). Weiters wurden sämtliche Informationen, die in diesem Kapitel über Polymer genannt werden, von der Dokumentation zu Polymer (\url{http://www.polymer-project.org/}) entnommen \citereset \autocite[siehe][]{Polymer}.

Die Verwendung von Google Polymer ist um einiges einfacher, als die von nativen Web-Components. Der empfohlene Weg um Polymer korrekt zu installieren ist über \glqq bower\footnote{Bower kann über npm mit Hilfe von \lstinline|npm install -g bower| installiert werden. Mehr Informationen zu Bower auf \href{http://bower.io/}{http://bower.io/}}\grqq . Dadurch, dass im Unterordner \lstinline|praxisprojekt/polymer| bereits eine \lstinline|bower.json|-Datei vorhanden ist, muss man lediglich \lstinline|bower install| in der Konsole ausführen, um Polymer korrekt zu installieren. In der \lstinline|bower.json|-Datei sind bereits sämtliche Konfigurationen vorhanden, um die richtige Version von Polymer (0.2.2) zu bekommen, mit der das Praxisprojekt entwickelt wurde.

Folgend wird zuerst ein Beispiel mit einer vordefinierten Komponente und Polymer gezeigt und daraufhin folgt nähere Erläuterung der beiden selbst entwickelten Komponenten.

\textbf{Vordefinierte Elemente in Polymer}

Wie bereits in Kapitel \ref{sec:3_Polymer} auf Seite \pageref{sec:3_Polymer} erklärt, gibt es bei Polymer einige vordefinierte Elemente, die den Entwicklern einiges erleichtern soll beziehungsweise einen gewissen Standard in die Entwicklung bringen soll.

Um Polymer auf einer Seite benutzen zu können, muss zuerst die Polyfill-Unterstützung geladen werden. Dies entspricht der gelben Schicht der bereits geklärten Abbildung \ref{fig:3_polymer_architecture} auf Seite \pageref{fig:3_polymer_architecture}.
Diese Datei soll vor sämtlicher DOM-Manipulation geladen werden, um garantieren zu können, dass sämtliche, gewünschte Funktionen zur Verfügung stehen. Im nächsten Schritt kann bereits das gewünschte Element in der Hauptdatei geladen und danach deklariert werden. Im Code-Beispiel \ref{lst:4_polymerSetup} auf Seite \pageref{lst:4_polymerSetup} werden die bereits genannten Schritte gezeigt und darüber hinaus wird die vom \lstinline|<polymer-ajax>|-Element zur Verfügung gestellte Schnittstelle benutzt.

\begin{lstlisting}[language=HTML, caption={Einsatz einer Polymer-Komponente}, label={lst:4_polymerSetup}, escapeinside={@}{@}]
<head>
  <script src="bower_components/platform/platform.js"></script>
  <link rel="import" href="bower_components/polymer-ajax/polymer-ajax.html">
</head>
<body>
  <polymer-ajax url="http://example.com/json" handleAs="json"></polymer-ajax>
  <script>
    window.addEventListener('polymer-ready', function(e) {
      var ajax = document.querySelector('polymer-ajax');

      ajax.addEventListener('polymer-response', function(e) {
        console.log(this.response);
      });

      ajax.go(); // Call its API methods.
    });
  </script>
</body>
\end{lstlisting}

Elemente können jegliche Art von Attributen übergeben bekommen. Valide Attribute zu definieren obliegt dem Autor der Komponente. Bei vordefinierten Elementen findet man die erwarteten Typen für jedes Attribute in der Element-Referenz\footnote{Mehr Information zu den Element-Referenzen auf \url{http://www.polymer-project.org/docs/elements/}}.

Polymer bietet weitere Unterstützungen, die sehr hilfreich bei der Visualisierung beziehungsweise Gestaltung von Elementen sind. Beispielsweise führt es das \lstinline|unresolved|-Attribut ein, um somit \glqq FOUC\footnote{Flash of unstyled Content}\grqq\ vorzubeugen. Es gibt eine Vielzahl von CSS-Selektoren, die dabei helfen Polymer-Elemente besser gestalten zu können, die aber nicht in dieser Arbeit näher erwähnt werden, jedoch später bei der Beantwortung der Forschungsfrage als Pluspunkt für Polymer gewertet werden.

\textbf{Diagramm-Komponente}

Wie bereits bei der vordefinierten Polymer-Komponente wird auch für die Diagramm-Komponente zuerst das Skript der Plattform geladen und im Anschluss darauf die Komponente. Dies reicht bereits in der Hauptdatei aus, um die Komponente verwenden zu können. In der Datei \lstinline|polymer-chart.html| wird zuerst die Basis von Polymer namens \lstinline|polymer.html| geladen. Es sind keine weiteren Dateien notwendig, um ein grundlegendes Element erstellen zu können. Für die Diagramm-Komponente hingegen muss wie bei der nativen Implementation der Komponente \lstinline|canvasjs.html| geladen werden, um ein Diagramm zu erzeugen. Polymer erleichtert die Syntax ein klein wenig, was die Registrierung des Elements betrifft. Grundlegend funktioniert die Registrierung eines Elements mit Hilfe des Polymer-Objekts, wie Code-Beispiel \ref{lst:4_polymerDiagramm} auf Seite \pageref{lst:4_polymerDiagramm} veranschaulicht. Ein weiterer, wichtiger Punkt dieses Code-Beispiels ist, dass bereits sechs Lebenszyklus-Methoden vorhanden sind. Polymer fügt zwei weitere Lebenszyklus-Callback Methoden zu der Spezifikation des W3C hinzu. Tabelle \ref{tab:Lifecycle_Callback_Methoden_Polymer} auf Seite \pageref{tab:Lifecycle_Callback_Methoden_Polymer} erläutert die Gleichheiten beziehungsweise die neuen Callback-Methoden.

Dadurch, dass bei der Diagramm-Komponente sämtliches Markup durch die Bibliothek \lstinline|canvas.js| erstellt wird, muss sichergestellt werden, dass das Element von außen erreichbar ist. Standardmäßig wird Markup für eine Polymer-Komponente wie es in Code-Beispiel \ref{lst:4_polymerDiagramm2} auf Seite \pageref{lst:4_polymerDiagramm2} zu sehen ist. Dieses Beispiel ist direkt auf die Diagramm-Komponente angepasst. Der Name der Komponente muss, gleich wie in der Spezifikation, immer einen Bindestrich beinhalten, um valide zu sein. Weiters erkennt man bereits in den \lstinline|attributes=""| welche Eigenschaften der Benutzer der Komponente von außen steuern kann. Wie diese Eigenschaften von außen gesetzt werden können zeigt Code-Beispiel \ref{lst:4_polymerDiagramm3} auf Seite \pageref{lst:4_polymerDiagramm3}. Ein weiteres, wichtiges Merkmal bei Polymer-Komponenten ist, dass standardmäßig sämtliches Markup, das in der Komponenten-Datei (hier \lstinline|polymer-chart.html|) definiert ist, im Shadow-DOM liegt. Daher wird auch im Fall der Komponente das \lstinline|<content>|-Element verwendet, damit das dynamisch erzeugte Markup von \lstinline|canvas.js| hier gerendert wird.

Sämtliche Funktionen und Variablen, um die Komponente steuern beziehungsweise erstellen zu können bleibt gleich wie bei der nativen Implementation. Code-Beispiel \ref{lst:4_polymerDiagramm4} auf Seite \pageref{lst:4_polymerDiagramm4} zeigt den vollständigen Code der Komponente. Hierbei muss beachtet werden, dass \lstinline|this| in dem verwendeten Scope immer eine Referenz zum Polymer-Element repräsentiert.

\begin{lstlisting}[language=JavaScript, caption={Registrierung einer Polymer-Komponente}, label={lst:4_polymerDiagramm}, escapeinside={@}{@}]
Polymer('chart-live',{
  created: function(){},
  ready: function(){},
  attached: function(){},
  domReady: function(){},
  detached: function(){},
  attributeChanged: function(attrName, oldVal, newVal){},
});
\end{lstlisting}

\begin{lstlisting}[language=HTML, caption={Markup in einer Polymer-Komponente}, label={lst:4_polymerDiagramm2}, escapeinside={@}{@}]
<polymer-element name="chart-live" attributes="chartId chartClass dataLength updateInterval">
  <template>
    <content></content>
  </template>
</polymer-element>
\end{lstlisting}

\begin{lstlisting}[language=HTML, caption={Markup einer verwendeten Polymer-Komponente}, label={lst:4_polymerDiagramm3}, escapeinside={@}{@}]
<chart-live chartId="tempChart" updateInterval=1000 dataLength=2000 chartClass="chartLive2"></chart-live>
\end{lstlisting}

\lstinputlisting[language=JavaScript, firstline=3, lastline=57, caption={polymer-chart.html}, label={lst:4_polymerDiagramm4}]{./praxisprojekt/polymer/diagram/polymer-chart.html}

\begin{table}[h]
\centering
\begin{tabular}{ M{4cm} | M{4cm} | M{4cm} }
Callback-Name - Spezifikation & Callback-Name - Polymer &Aufgerufen, wenn \\
\hline
\hline
createdCallback & created & eine Instanz des Elements erstellt wurde\\
\hline
- & ready & das benutzerdefinierte Element vollständig aufbereitet wurde\\
\hline
attachedCallback & attached & eine Instanz in das Dokument eingefügt wurde\\
\hline
- & domReady & die Child-Elemente (Light DOM) erstellt wurden\\
\hline
detachedCallback & detached & eine Instanz vom Dokument entfernt wurde\\
\hline
attributeChangedCallback (attrName, oldVal, newCal) & attributeChanged (attrName, oldVal, newCal) & eine Eigenschaft hinzugefügt, upgedated, oder entfernt wurde\\
\end{tabular}
\caption[
Lebenszyklus-Callback Methoden bei Polymer
]
{Lebenszyklus-Callback Methoden bei Polymer}
\label{tab:Lifecycle_Callback_Methoden_Polymer}
\end{table}

\textbf{Menü-Komponente}

Von der Hauptdatei \lstinline|index.html| ist die Menü-Komponente sehr ähnlich zur Diagramm-Komponente. Es wird lediglich das \glqq Herz\grqq\ von Polymer namens \lstinline|platform.js| geladen und darauffolgend das selbst entwickelte Element. Im \lstinline|body| wird daraufhin bereits dieses Element verwendet. Weiters werden drei globale Funktionen definiert, welche für das Menü notwendig sind. Diese Funktionen sind im globalen Geltungsbereich, da sie für mehrere Komponenten benötigt werden, die jedoch nicht in dieser Arbeit besprochen werden.

Das selbst entwickelte Element unterscheidet sich sehr von der Diagramm-Komponente. Es beginnt mit dem Laden externer Skripte und folgend wird das Markup des Menüs festgelegt. Code-Beispiel \ref{lst:4_polymerMenu4} auf Seite \pageref{lst:4_polymerMenu4} zeigt den Beginn des Elements, wo bereits ein wichtiges Merkmal zu sehen ist. Der \lstinline|<style>|-Tag innerhalb des Templates lädt mit Hilfe mehrerer CSS-\lstinline|@import ""| Befehle diverse Dateien. Wichtig hierbei ist, dass Polymer dies erkennt und sämtliche Gestaltungsdateien in diesem \lstinline|<style>|-Tag einbettet. Dies hat zur Folge, dass sämtliche gestalterischen Angelegenheiten in diesem Element gekapselt sind und somit keinerlei Problem darstellen, wenn beispielsweise eine zweite Containerklasse in der Hauptdatei vorhanden ist. Das Markup der Menü-Komponente unterscheidet sich nur minimal zum Markup der nativen Implementation, deswegen wird es nicht genauer besprochen.

Code-Beispiel \ref{lst:4_polymerMenu5} auf Seite \pageref{lst:4_polymerMenu5} zeigt einen weiteren wichtigen Inhalt von Polymer. Es wird zuerst einer \glqq Immediate Function\grqq\ begonnen. Dies hat zur Folge, das sämtliche Funktionen innerhalb dieser \glqq Immediate Function\grqq\ nach außen hin gekapselt sind. Die Registrierung des Polymer-Elements funktioniert innerhalb dieser Funktion gleich. An Hand des Codes kann man sagen, welche Methoden öffentlich und von außen zugänglich sind und welche nicht, denn sämtliche private Methoden wurden mit einem \lstinline|_| vor dem Funktionsnamen gekennzeichnet.

\lstinputlisting[language=HTML, firstline=5, lastline=17, caption={polymer-menu.html}, label={lst:4_polymerMenu4}]{./praxisprojekt/polymer/menu/polymer-menu.html}

\lstinputlisting[language=JavaScript, firstline=63, lastline=79, caption={polymer-menu.html}, label={lst:4_polymerMenu5}]{./praxisprojekt/polymer/menu/polymer-menu.html}

